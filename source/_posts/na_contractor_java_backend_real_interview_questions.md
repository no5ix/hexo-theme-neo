---
title: NA contractor interview notes
date: 2025-02-19 02:45:08
tags:
- noodle
- Java
- NA
categories:
- Noodle
password: 'ees'
---



**. . .**<!-- more -->


# Pilot Training Questions

## Mock

### BQ

1.	Describe a major conflict within or outside your team and how you handled it, or how you dealt with a difficult team member.
    - Story: “There was a situation in a previous project where one of the team members and I disagreed on how to approach a technical solution. They wanted to go with a more complex solution that would take more time, but I felt that a simpler approach would be more efficient. Instead of arguing, I suggested that we both present our ideas to the team and get feedback. This helped bring clarity and eventually, we went with a balanced approach that combined the best of both ideas.”
2.	Describe a time when you had difficulty completing a task or making progress.
    - Story: “I once had trouble with a backend optimization task that seemed straightforward at first. I was hitting performance bottlenecks and nothing seemed to fix it. I reached out to a senior engineer for advice, and we reviewed the code together. It turned out I was overlooking some key database indexing, which once fixed, improved performance significantly.”
3.	If your manager asks you to change something that you think is already good enough, how would you handle it?
    - Story: “If my manager asks me to change something I feel is fine, I first try to understand their reasoning. Maybe there’s something I missed or a bigger picture I wasn’t considering. If it’s not immediately clear, I’ll ask for more context, and then I’ll make the changes. Sometimes, feedback can lead to better solutions, even when things feel good already.”
4.	Why do you want to join our team?
    - Story: “I admire your company’s focus on innovation and the way your team handles challenges. The projects you’re working on align well with my background in building scalable backend services, and I’d love to be part of that. Plus, I’m really looking for a team where collaboration and growth are encouraged.”
5.	Are you familiar with Agile processes and Waterfall methodology?
    - Story: “Yes, I’ve worked in Agile teams, especially using Scrum. We’ve had sprints, stand-ups, and retrospectives to keep things moving. On the other hand, I’ve also worked in a Waterfall environment where things were more structured and followed a set timeline. I think Agile is great for flexibility and iterative development, but Waterfall can work well when requirements are clear upfront.”
6.	What does a typical day look like for you?
    - Story: “On a typical day, I start by checking my emails and any notifications about code reviews or issues in the backlog. Then, I focus on the tasks I’ve committed to for the sprint, which could involve writing code, fixing bugs, or collaborating with team members. I also make time to sync with the team through stand-ups or meetings.”
7.	What do you think are the most important factors for a successful team?
    - Story: “For me, open communication and trust are key. When everyone feels comfortable sharing ideas and challenges, the team can move faster and solve problems more effectively. Also, having a shared goal and a good work ethic helps keep everyone aligned.”
8.	If you are working on a sprint and your manager suddenly assigns you a new task that needs to be finished as soon as possible, what would you do?
    - Story: “First, I’d ask for clarity on the priority of the new task and its deadline. If it’s urgent, I’d immediately see if I can rearrange my tasks or seek help from others. Then, I’d focus on delivering that task with high quality and return to the sprint tasks afterward.”
9.	Tell me something about yourself that is not on your resume.
    - Story: “I’m really passionate about learning new things outside of work. I like picking up new hobbies, whether it’s learning a new language, cooking, or playing a musical instrument. It helps me stay balanced and creative.”
10.	Tell me about a difficult project or challenge you faced and how you handled it.
    - Story: “I worked on a project where we had to migrate a monolithic application to microservices, and the timelines were tight. It was challenging, especially when dealing with inter-service communication and database consistency. But by breaking the task into smaller parts and working closely with the team, we managed to migrate successfully within the deadline.”
11.	Share a time when you made a mistake in a team setting, how you resolved it, and what you learned from the experience.
    - Story: “I once miscommunicated a requirement during a project, which caused some unnecessary work. Once I realized the mistake, I immediately owned up to it, clarified the requirement, and helped the team get back on track. I learned the importance of clear communication and checking in with stakeholders regularly.”
12.	Do you have on-call experience, and are you comfortable with overnight on-call duties?
    - Story: “Yes, I’ve had on-call experience in my previous job. I’m comfortable with the responsibility, especially when it means ensuring our systems are running smoothly. We had a clear escalation path and communication strategy, which helped me handle it effectively.”
13.	Do you know what pair programming is, and what are your thoughts on it?
    - Story: “Yes, I’ve tried pair programming a few times, and I think it can be a great way to solve complex problems and share knowledge. I like how it encourages collaboration and immediate feedback, but I also think it’s important to balance it with solo work so everyone has time to focus deeply.”
14.	If you are mentoring a junior colleague and they propose a new idea to the team, how would you handle it?
    - Story: “I would listen to their idea carefully and, if it’s a good one, I’d encourage them to present it to the team. It’s important to empower junior team members to share their ideas because it can lead to fresh perspectives and innovative solutions.”
15.	Describe your code review process. What do you focus on during a code review?
    - Story: “During a code review, I focus on functionality first to make sure the code does what it’s supposed to do. I also look for readability, maintainability, and test coverage. I like to leave constructive feedback and offer suggestions for improvements rather than just pointing out issues.”

## Leetcode

- Arrays
    - Two sum: https://leetcode.com/problems/two-sum/description/
    - Contains Duplicate: https://leetcode.com/problems/contains-duplicate/description/
    - Group Anagram: https://leetcode.com/problems/group-anagrams/description/
    - Best Time to Buy and Sell Stock: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
    - Top K Frequent Elements: https://leetcode.com/problems/top-k-frequent-elements/description/
    - Longest Consecutive Sequence: https://leetcode.com/problems/longest-consecutive-sequence/description/
- Two Pointer
    - Valid Palindrome: https://leetcode.com/problems/valid-palindrome/description/
    - 3Sum: https://leetcode.com/problems/3sum/description/
- Binary Search
    - Binary Search: https://leetcode.com/problems/binary-search/description/
    - Search in Rotated Sorted Array: https://leetcode.com/problems/search-in-rotated-sorted-array/description/
    - Koko Eating Bananas: https://leetcode.com/problems/koko-eating-bananas/description/
- Sliding Window
    - Longest Substring Without Repeating Characters: https://leetcode.com/problems/longest-substring-without-repeating-characters/description/
- Linked List
    - Reverse Linked List: https://leetcode.com/problems/reverse-linked-list/description/
    - Merge Two Sorted Lists: https://leetcode.com/problems/merge-two-sorted-lists/description/
    - Linked List Cycle: https://leetcode.com/problems/linked-list-cycle/description/
    - Copy List with Random Pointer: https://leetcode.com/problems/copy-list-with-random-pointer/description/
- Stack & Queue
    - Valid Parentheses: https://leetcode.com/problems/valid-parentheses/description/
    - Min Stack: https://leetcode.com/problems/min-stack/description/
    - Implement Queue using Stacks: https://leetcode.com/problems/implement-queue-using-stacks/description/
- DFS & BFS
    - Number of Islands: https://leetcode.com/problems/number-of-islands/description/

## Rest API

- User Info
    - Given URL: https://jsonplaceholder.typicode.com/users
    - You need to write a REST api to call the given URL and return a user with its "name, username, zipcode"
    - for example, if user id is 1, you should return a JSON file with username "Bret", email "Sincere@april.biz" and zipcode "92998-3874"
        - HINT: use "Rest Template"
    - Result: OPEN a webbrowser and enter: http://localhost:8080/user/1 should return the correct result.
    - Follow-up: id only 1-10, how to handle /user/11 → print in the page “Invalid ID”
    - Solution
- Movie
    - https://jsonmock.hackerrank.com/api/movies/search/?Title=waterworld 
    - GIVEN Above URL. Write a MVC with rest api to fetch this URL and then create new rest APIs to:
        - Show all movies
        - Show all movies sort by year
        - Fetch a particular movie based on its imdbID.
        - Hint: have multiple pages
    - Solutions
        - look at this URL date, it has multiple pages, each page has 10 movies, we need to fetch all pages to get a full list of movies and then filter to find the particular movie by imdbID
        - each movie has Title, Year, imdbID three fields, we need to create a model to match them
        - need org.json.simple to parse the json object from the given URL
- Build a POST API /greetings with below requirements
    - Create a POST API /greetings
    - INPUT – json array: [{"name":"john doe", "work": "engineer"}, {"name":"jane who", "work": "manager"}] 
    - OUTPUT - json: {"data": ["Hello john the engineer", "Hello jane the manager"], "timestamp": "${requested_timestamp}"
    - Use postman to call the API and pass input, it should return the correct response.




# concepts

## In java, difference between @controller and @restcontroller

In Java, specifically in the Spring framework, both `@Controller` and `@RestController` are annotations used for building web - related components. Here are the key differences between them:

### 1. Function and Purpose
- **`@Controller`**
    - It is a stereotype annotation in Spring MVC. It is mainly used to mark a class as a Spring MVC controller. A controller class typically handles HTTP requests, processes them, and then returns a view name. The view resolver in Spring MVC will then use this view name to render an appropriate view (such as a JSP page, Thymeleaf template, etc.) to the client.
- **`@RestController`**
    - It is a combination of `@Controller` and `@ResponseBody`. This annotation is designed for building RESTful web services. When a class is marked with `@RestController`, all the handler methods in this class will automatically serialize the return value to the HTTP response body in a format like JSON or XML by default.

### 2. Return Value Handling
- **`@Controller`**
    - By default, the return value of a method in a `@Controller` class is treated as a view name. For example:
```java
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class MyViewController {
    @GetMapping("/view")
    public String showView() {
        return "myView";
    }
}
```
    - In this code, the method `showView` returns the string `"myView"`, and Spring MVC will look for a view with this name to render.
- **`@RestController`**
    - The return value of a method in a `@RestController` class is directly serialized and sent as the HTTP response body. For example:
```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MyRestController {
    @GetMapping("/data")
    public String getData() {
        return "This is some data";
    }
}
```
    - When a client makes a request to `/data`, the string `"This is some data"` will be sent directly in the response body.

### 3. Usage Scenarios
- **`@Controller`**
    - It is suitable for traditional web applications where you need to render views based on user requests. For example, an e - commerce website where you need to display product lists, user profiles, etc. in HTML pages.
- **`@RestController`**
    - It is ideal for building RESTful APIs. These APIs can be consumed by various clients such as mobile applications, single - page web applications, etc. For example, a backend API for a mobile banking application that provides services like getting account balance, transaction history, etc. 


## in kafka, how to handle schema evolution

Here are several common methods to handle schema evolution in Apache Kafka:

### 1. Using Schema Registry
#### Avro with Confluent Schema Registry
- **Principle**
    - Confluent Schema Registry is a widely used tool for managing schemas in Kafka. It stores schemas in a central repository and enforces compatibility rules between different versions of schemas. When using Avro serialization, producers and consumers can interact with the Schema Registry to ensure that the data they produce and consume adheres to the defined schemas.
- **Steps**
    - **Producer side**: When a producer sends data, it first checks if the schema of the data exists in the Schema Registry. If not, it registers the new schema. The registry then assigns a unique ID to the schema. The producer serializes the data using Avro and includes the schema ID in the message.
    - **Consumer side**: The consumer receives the message with the schema ID, fetches the corresponding schema from the Schema Registry, and deserializes the data using that schema.
- **Compatibility Modes**
    - **Backward compatibility**: Newer versions of the schema can be read by older consumers. For example, adding a new optional field to an Avro record is backward - compatible.
    - **Forward compatibility**: Older versions of the schema can be read by newer consumers. For example, removing a non - required field is forward - compatible.
    - **Full compatibility**: It combines backward and forward compatibility.

#### Protobuf with Schema Registry
- Similar to Avro, Protocol Buffers can also be used with a schema registry. Protobuf has its own serialization and deserialization mechanisms, and the schema registry helps in managing different versions of Protobuf schemas.

### 2. Designing Flexible Schemas
#### Use Optional Fields
- When defining your data schema, mark non - essential fields as optional. For example, in Avro, you can define a field like this:
```json
{
    "name": "optionalField",
    "type": ["null", "string"],
    "default": null
}
```
- This allows you to add new fields in future schema versions without breaking existing consumers that may not expect these new fields.

#### Avoid Breaking Changes
- Do not remove or rename existing required fields. If you need to change the meaning of a field, it's better to add a new field and gradually deprecate the old one.

### 3. Versioning in the Application Code
#### Producer - Side Versioning
- The producer can explicitly include a version number in the message. For example, you can add a `version` field to your data structure:
```java
public class MyMessage {
    private int version;
    private String data;

    // Getters and setters
}
```
- The producer can increment the version number when there is a schema change.

#### Consumer - Side Version Handling
- The consumer can check the version number in the message and handle the data differently based on the version. For example:
```java
if (message.getVersion() == 1) {
    // Handle data in version 1 format
} else if (message.getVersion() == 2) {
    // Handle data in version 2 format
}
```

### 4. Using Kafka Connect with Schema Evolution Support
- Kafka Connect is a tool for moving data between Kafka and other systems. Some connectors support schema evolution. For example, the JDBC connector can handle changes in the database schema and propagate these changes to Kafka topics while maintaining compatibility.

在 Apache Kafka 中，处理模式演变（Schema Evolution）有以下几种常见方法：

### 1. 使用模式注册表
#### 结合 Confluent 模式注册表使用 Avro
- **原理**
    - Confluent 模式注册表是 Kafka 中广泛使用的管理模式的工具。它将模式存储在中央存储库中，并对不同版本的模式执行兼容性规则。在使用 Avro 序列化时，生产者和消费者可以与模式注册表交互，以确保它们生产和消费的数据符合定义的模式。
- **步骤**
    - **生产者端**：生产者发送数据时，首先检查数据的模式是否存在于模式注册表中。如果不存在，则注册新模式。注册表会为该模式分配一个唯一的 ID。生产者使用 Avro 对数据进行序列化，并在消息中包含模式 ID。
    - **消费者端**：消费者接收到包含模式 ID 的消息后，从模式注册表中获取相应的模式，并使用该模式对数据进行反序列化。
- **兼容性模式**
    - **向后兼容**：新模式可以被旧版本的消费者读取。例如，向 Avro 记录中添加一个新的可选字段就是向后兼容的。
    - **向前兼容**：旧模式可以被新版本的消费者读取。例如，移除一个非必需字段是向前兼容的。
    - **完全兼容**：同时具备向后兼容和向前兼容的特性。

#### 结合模式注册表使用 Protocol Buffers（Protobuf）
- 与 Avro 类似，Protocol Buffers 也可以与模式注册表结合使用。Protobuf 有自己的序列化和反序列化机制，模式注册表有助于管理不同版本的 Protobuf 模式。

### 2. 设计灵活的模式
#### 使用可选字段
- 在定义数据模式时，将非必需字段标记为可选。例如，在 Avro 中可以这样定义一个字段：
```json
{
    "name": "optionalField",
    "type": ["null", "string"],
    "default": null
}
```
- 这样，在未来的模式版本中添加新字段时，不会破坏可能不期望这些新字段的现有消费者。

#### 避免重大更改
- 不要移除或重命名现有的必需字段。如果需要更改字段的含义，最好添加一个新字段，并逐步弃用旧字段。

### 3. 在应用代码中进行版本控制
#### 生产者端版本控制
- 生产者可以在消息中显式包含版本号。例如，可以在数据结构中添加一个 `version` 字段：
```java
public class MyMessage {
    private int version;
    private String data;

    // Getters 和 setters
}
```
- 当模式发生变化时，生产者可以递增版本号。

#### 消费者端版本处理
- 消费者可以检查消息中的版本号，并根据版本不同对数据进行不同的处理。例如：
```java
if (message.getVersion() == 1) {
    // 处理版本 1 格式的数据
} else if (message.getVersion() == 2) {
    // 处理版本 2 格式的数据
}
```

### 4. 使用支持模式演变的 Kafka Connect
- Kafka Connect 是用于在 Kafka 和其他系统之间移动数据的工具。一些连接器支持模式演变。例如，JDBC 连接器可以处理数据库模式的更改，并将这些更改传播到 Kafka 主题，同时保持兼容性。 


## kafka Exactly one semantics

Kafka 提供三种消息传递语义，分别是最多一次（At most once）、至少一次（At least once）和精确一次（Exactly once），它们的区别如下：

### 最多一次（At most once）
- **生产者**：消息发送后，不管是否成功写入 Kafka 就继续发送下一条消息。如果发送失败，不会重试。比如网络抖动导致消息没发出去，生产者也不会重新发送。
- **消费者**：消费消息前先提交偏移量，再处理消息。若处理过程中消费者崩溃，已提交偏移量的消息不会再次处理，可能造成消息丢失。
- **应用场景**：适用于对数据丢失容忍度较高，对性能要求较高的场景，如实时日志收集，少量日志丢失不影响整体分析。

### 至少一次（At least once）
- **生产者**：消息发送失败会重试，保证消息至少被写入 Kafka 一次。但如果写入成功，而确认响应丢失，生产者重试会导致消息重复写入。
- **消费者**：先处理消息，处理完成后再提交偏移量。若处理完消息还未提交偏移量时消费者崩溃，重启后会重新处理之前的消息，导致消息重复消费。
- **应用场景**：适用于对数据丢失零容忍，但能接受数据重复的场景，如数据统计分析，重复数据可以通过去重处理。

### 精确一次（Exactly once）
- **生产者**：有幂等生产者和事务性生产者两种机制。幂等生产者借助 PID 和序列号避免同一分区内重复写入；事务性生产者保证跨分区消息发送的原子性，失败可回滚。
- **消费者**：结合生产者事务操作与手动提交偏移量，在事务中处理消息并在完成后提交，故障时事务回滚，确保消息不重复不丢失。
- **应用场景**：适用于对数据准确性要求极高的场景，如金融交易系统，每笔交易必须精确处理一次。 

### Concept
Exactly-once semantics means that each message is written to a Kafka topic and consumed and processed exactly once, ensuring data consistency.

### Challenges
- **Producer**: Retries may lead to duplicate message writes due to the failure of receiving acknowledgments.
- **Consumer**: Incorrect timing of offset commits may result in duplicate message processing or message loss.

### Solutions
- **Producer**
    - **Idempotent Producer**: Introduced since Kafka 0.11.0, it avoids duplicate writes by means of the Producer ID (PID) and sequence numbers.
    - **Transactional Producer**: Ensures the atomicity of message sending across multiple partitions, and in case of failure, the transaction can be rolled back.
- **Consumer**: Combine the producer's transaction operations with manual offset commits. Process messages within a transaction and commit the offset after the processing is completed. When a failure occurs, the transaction is rolled back to ensure there are no message-related issues. 


# bq

# coding

- find kth element in an array
- find the middle node in a linked list